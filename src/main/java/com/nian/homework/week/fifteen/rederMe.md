### 一 JVM

#### 1 图

![](jvm\简单.png)

#### 2 思考

​	JVM是JAVA得以运行在不同平台，而运行起来没有什么分别，JVM承担了JAVA的底层工作原理，规定了类文件结构，并且定义了类加载机制。根据JMM的内存模型划分了不同区域的工作及资源的使用，最重要的堆和栈就是在这里，堆主要存放实例化的对象，栈存放局部变量和引用变量。另外一个点则是GC策略，很多人都会忽略，像CMS GC和G1 GC都会在一定程序上优化性能，还有就是内存的分配的问题，结合实际情况和硬件配置对内存进行合理分配，也会对性能有一定提升。再者就是出问题之后的性能监控和故障处理，可以使用提供很多现成的工具帮助定位问题，但更多的还是要依靠经验。



### 二 NIO

#### 1 图

![](nio\nio2.png)



#### 2 思考

​	NIO主要用I/O多路复用技术改进了传统的BIO结构，解决了线程阻塞问题，从而大幅度提高了使用效率。比较友好的主从Reactor多线程模式，主Reactor只负责与客户端的交互，经过Acceptor处理得到对应的socketChannel，将其注册到subReactor的selector上，处理对应的I/O操作，这样的设计充分利用了资源。值得注意的是NioSocketAcceptor中的selector，一般可以设置为cpu的个数+2，可以减少线程切换带来的开销。



### 三 并发编程

#### 1 图

![](并发编程\简单2.png)

#### 2 思考

​		并发编程是使用多线程来代替之前的单线程处理，因为cpu往往不是系统性能瓶颈，所以可以开多线程去处理对应业务来提高效率，分别有需要extends的Thread（一般不建议使用）和需要implements的Runnable和可以把数据带回来的Callable，按自己需求使用对应的线程，可以使用线程池来提升的线程的使用效率（减少资源消耗），可以自己使用ExecutorService创建原生线程池或者使用Executors提供的现成的线程池，原生线程池需要注意队列的大小及线程数的设置。使用时的核心是锁的设置，JDK分别提供了synchronized和lock来供大家使用，同时还有volatile可以在部分场景代替加锁，来减少资源的消耗。部分场景可以使用JDK提供的并发工具，也可以使用加强后的容器，解决了同步问题，但是会降低系统效率，谨慎使用。



### 四 Spring 和 ORM 等框架

#### 1 图

![](spring框架及orm\简单.jpg)

#### 2 思考

​	spring的主要框架模块分成这几块，核心模块主要负责了Bean的创建和装配，上下文模块，AOP模块负责了切面和事务管理，web模块提供了web相关的上下文，MVC模块包含了大量试图技术，DAO模块负责对数据库的交互，ORM则是提供了映射关系模型。常见的ORM映射框架有hibernate和mybits，hib是完整的ORM映射框架，比较重量级，但是可以提供封装比较完整全面的sql操作，不关心具体使用的数据库。mybitis则是比较轻量级，相对依赖于sql的编写，关联具体数据库，但是比较容易上手。mybitis还有plus版本对本身进行了加强，提供了更加友好的sql操作，市面上也有部分公司采用jpa+mybits的形式来管理ORM层。



### 五 MySQL 数据库和 SQL

#### 1 图



![](mysql\简单.png)

#### 2 思考

​	使用mysql首先要在表设计的时候对字段类型所有了解，知道在具体使用场景时应该和数据库哪个字段类型相匹配，尽量设置为not null，或者给默认值，null会使索引和统计变得负责。创建时对索引的创建也是一种讲究，包括主键索引、普通索引等，选择索引实现，如最常使用的B+Tree同时还要选择适合自己使用场景的索引引擎，最常用的如InnoDB。创建好表结构之后，就是在使用的查询，需要了解sql执行时每一个关键字的先后顺序，是否使用到索引（sql优化的关键点），不同数据库对事务的隔离级别也不同。对于慢sql可以使用Explain分析语句执行情况，是否使用到索引，扫了多少条记录等。



### 六 分库分表

#### 1 图

![](分库分表\简单.webp)

#### 2 思考

​	当我们的系统用户、业务水平增长到一定数据，单个库表很难支撑我们的数据量和性能的平衡时，就会有分库分表的考虑。首先是拆分的方法，有垂直拆分和水平拆分，垂直拆分多是按业务模块，但可能存在业务之间差异大，改造量较大，sql查询割裂的问题。水平拆分需要制定路由规则。单表数据最好是控制在一千万以内，在一定规模之后，还可以使用读写分离来提高效率。在分表分库之后，还需要考虑分布式事务的问题，主要分类为XA事务和BASE事务，现在主要运行的还是BASE事务偏多一些，BASE的主要模式有AT，TCC，SAGA，根据自己需求选择对应的事务模式。



### 七 RPC 和微服务

#### 1 图

![](rpc与微服务\微服务.webp)

​	                                                      ![](C:\Users\jialei\Desktop\总结\rpc与微服务\rpc.jpg)    



#### 2 思考

​	在系统规模达到一定时，单机来提供完整的服务也会变得越来越吃力，这时就会产生的微服务的概念。各自成完整的功能模块，可以向外提供服务。通过注册中心，如ZooKeeper、Eureka、Consul 、Nacos，CoreDNS等，再加上配置中心，可以自动注册发现服务，通过熔断限流等等功能保证服务可用性。不同服务之间就会存在通信问题，rpc便由此诞生，rpc的核心则是关注于服务暴露、远程代理对象、通信、序列化、编码内容。微服务架构使整个系统可以更好的进行扩展，解耦，但是微服务自身也需要良好的通信环境、健壮性、可用性。



### 八 分布式缓存

#### 1 图

​	

![](分布式缓存\简单.png)

![](分布式缓存\问题.png)

#### 2 思考

​	在cpu和硬盘的速度不匹配的背景下，就需要内存来做速度的平衡，就需要我们的缓存来做数据的储存。现在市面上主要以redis为主，根据自己的业务需求分为单机部署、主从模式、集群部署、哨兵模式。但目前成型的公司一般都比如选择使用阿里云提供的redis服务，保证高可用性，毕竟自己去维护redis服务器还是不容易的。但是除了高可用性外，在使用过程中还是会存在问题的，比如缓存穿透、缓存雪崩、缓存一致性等一些列问题，这就需要根据自己的业务场景再结合自身经验去对应处理解决。



### 九 分布式消息队列

#### 1 图

![](分布式消息队列\简单.jpg)

#### 2 思考

​	消息队列中间件是分布式系统中重要的组件，市面上主要使用的有各种MQ。消息队列主要解决了异步处理的问题，无需阻塞线程，同时可以使业务进行解耦，不影响其他业务的处理。流量削峰也是常见的使用场景，在某一时刻的流量暴增，为了系统的可用性，消息队列可以对流量济宁直接控制。日志的存储和转发也是消息队列经常使用到的场景。点对点通讯、消息通知都是非常常见也非常适合消息队列的场景。要控制和注意的是如何做到消息队列的精准发送，发送1次或者多次，接受1次或者多次的情况是消息队列核心。
